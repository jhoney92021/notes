*************** __proto__ *****************

obj1.newProperty = "newProperty!";
obj1.__proto__.anotherProperty = "anotherProperty!";
console.log(obj1.anotherProperty); // anotherProperty!
console.log(obj1.newProperty); // newProperty!
// What about obj2?
console.log(obj2.newProperty); // undefined
console.log(obj2.anotherProperty); // anotherProperty! <= THIS IS THE COOL PART!


Major PROS of Prototype

    One memory space for all! If you are creating lots of the same object and use prototype, it can save you significant memory
    Great for general methods for objects
    We can access prototype methods with just using .method or .property.
    The interpreter will go through all prototypes in the prototype chain to check if any of them have the called method or property before giving up (it'll return/use the first match it finds).

Major CONS of Prototype

    Methods generated in prototype cannot access the private variables inside the constructor function
    Lots of prototypes can be hard to read




// After we create our MyObjConstructor:
MyObjConstructor.prototype.methodName = function() {
  //do stuff here!
}



function Cat(catName) {
  var name = catName;
  this.getName = function() {
    return name;
  };
}
//adding a method to the cat prototype
Cat.prototype.sayHi = function() {
  console.log('meow');
};
//adding properties to the cat prototype
Cat.prototype.numLegs = 4;
var muffin = new Cat('muffin');
var biscuit = new Cat('biscuit');
console.log(muffin, biscuit);
//we access prototype properties the same way as we would access 'own' properties
muffin.sayHi();
biscuit.sayHi();
console.log(muffin.numLegs);
// we may change an instance's attributes rather than keeping the value set by prototype
muffin.numLegs = 3;
// poor mutant cats: muffin.__proto__.numLegs ++;
// doing this to muffin will cause all the cats to have 5 legs, but muffin will still have 3 legs

